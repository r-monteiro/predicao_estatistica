# -*- coding: utf-8 -*-
"""Trabalho_estatistica_indutiva_T2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/113Sz3BeqqxWBfdjv77m_8TK0e-NNnr7a

#PREPARAÇÃO DO AMBIENTE
"""

#importando as bibliotecas python.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn import metrics
from sklearn.model_selection import train_test_split
import statsmodels.api as sm

from google.colab import drive

# MONTA NO GOOGLE DRIVE.
drive.mount('/content/drive')

# CARREGA O ARQUIVO.
dataset1 = '/content/drive/MyDrive/estatistica_indutiva/dataset1.csv'
df = pd.read_csv(dataset1)
dataset2 = '/content/drive/MyDrive/estatistica_indutiva/dataset2.csv'
df2 = pd.read_csv(dataset2)

"""#LIMPEZA E TRATAMENTO DOS DADOS"""

df.shape

df.head()

df.tail()

df.info()

df.isnull().sum()

df.dropna(inplace = True)

df.duplicated().sum()

df.reset_index(inplace = True, drop = True)

dummies = pd.get_dummies(df['ocean_proximity'])
df = pd.concat([df, dummies], axis = 1)
df.head()

df = df.drop(['ocean_proximity'], axis = 1)
df.head()

df[['<1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN']] = df[['<1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN']].astype(int)
df.head()

df.describe().round(4)

"""#CORRELAÇÃO"""

df.corr().round(4)

#heatmap
fig = plt.figure(figsize=(8, 5))
ax = fig.add_axes([0, 0, 1, 1])

sns.heatmap(df.corr().round(2), annot=True, vmin=-1, vmax=1, cmap='coolwarm')
ax.set_title('Matriz de correlação', fontsize=15, pad=10)
plt.show()

#calculo correlação
corre = df['total_bedrooms'].corr(df['households'])
print(f"Correlação entre 'total_bedrooms' e 'households': {corre}")

#grafico dispersão linear
plt.figure(figsize=(8, 6))
plt.scatter(df['households'], df['total_bedrooms'], alpha=0.5)
plt.title('Gráfico de Dispersão: Número Total Residências em Um Quarteirão vs. Total de Quartos.')
plt.xlabel('Número Total Residências em Um Quarteirão')
plt.ylabel('Total de Quartos.')
plt.grid(True)
plt.show()

#grafico dispersão linear
plt.figure(figsize=(8, 6))
plt.scatter(df['latitude'], df['longitude'], alpha=0.5)
plt.title('Gráfico de Dispersão: latitude vs longitude')
plt.xlabel('latitude')
plt.ylabel('longitude')
plt.grid(True)
plt.show()

"""#REGRESSÃO LINEAR MONOVARIADA"""

#variáveis
x_variable = 'total_bedrooms'
y_variable = 'population'

# Preparação dos dados
X = df[[x_variable]]
y = df[y_variable]

#cria e ajusta o modelo de regressão linear
model = LinearRegression()
model.fit(X, y)

#coeficientes de regressão
intercept = model.intercept_
slope = model.coef_[0]

#gera valores preditos
y_pred = model.predict(X)

#plot gráfico
plt.figure(figsize=(10, 6))
sns.scatterplot(x=df[x_variable], y=df[y_variable], color="blue", alpha=0.5)
plt.plot(df[x_variable], y_pred, color="red", label=f'Linha de Regressão: y = {intercept:.2f} + {slope:.2f}x')
plt.xlabel(x_variable)
plt.ylabel(y_variable)
plt.title(f'Regressão Linear Monovariada: {x_variable} vs {y_variable}\nFórmula: y = {intercept:.2f} + {slope:.2f}x')
plt.legend()
plt.grid(True)
plt.show()

"""#REGRESSÃO LINEAR MULTIVARIADA"""

y = df['population']

X = df[['households', 'total_bedrooms']]

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = 21)

X_train_constante = sm.add_constant(X_train)

modelo_statsmodels = sm.OLS(y_train, X_train_constante, hasconst = True).fit()

print(modelo_statsmodels.summary())

modelo = LinearRegression()

modelo.fit(X_train, y_train)

print('R² = {}'.format(modelo.score(X_train, y_train).round(4)))

y_previsto = modelo.predict(X_test)

print('R² = {}'.format(metrics.r2_score(y_test, y_previsto).round(4)))

entrada = X_test[0:1]
entrada

EQM = metrics.mean_squared_error(y_test, y_previsto).round(4)
REQM = np.sqrt(metrics.mean_squared_error(y_test, y_previsto)).round(4)
R2 = metrics.r2_score(y_test, y_previsto).round(4)

print('O modelo possui erro quadrático médio de {0:.2f}'.format(EQM))
print('O modelo possui raíz do erro quadrático médio de {0:.2f}'.format(REQM))
print('O modelo possui coeficiente de determinação de {0:.2f}%'.format(R2 * 100))

y_previsto_train = modelo.predict(X_train)

#linha regressão linear
model = LinearRegression()
model.fit(X_train, y_train)
y_pred_train = model.predict(X_train)

#calcula r² (já foi feito anterior)
r_squared = r2_score(y_train, y_pred_train)

#plota gráfico
plt.figure(figsize=(8, 5))
sns.scatterplot(x=y_train, y=y_pred_train, color='crimson')
plt.title('Dispersão Linear Multivariada: Estimativa population (y)', fontsize=18, pad=10)
plt.xlabel('households e total_bedrooms', fontsize=12)
plt.plot([y_train.min(), y_train.max()], [y_train.min(), y_train.max()], 'k--', lw=2)
plt.text(0.05, 0.95, f'R² = {r_squared:.4f}', transform=plt.gca().transAxes, fontsize=12, verticalalignment='top')
plt.show()

"""#SERIES TEMPORAIS


"""

#gerando dados de exemplo para a série temporal
np.random.seed(0)
dates = pd.date_range(start='2023-01-01', end='2023-12-31', freq='D')
temperature = 20 + 10 * np.sin(2 * np.pi * dates.dayofyear / 365) + np.random.normal(0, 2, len(dates))

#cria dataframe com os dados
df_temp = pd.DataFrame({'Date': dates, 'Temperature': temperature})

#plota gráfico
plt.figure(figsize=(12, 6))
plt.plot(df_temp['Date'], df_temp['Temperature'], color='tab:blue')
plt.title('Temperatura Diária ao Longo de 2023', fontsize=15)
plt.xlabel('Data', fontsize=12)
plt.ylabel('Temperatura (°C)', fontsize=12)
plt.grid(True)
plt.show()

df2.head()

print(df2.columns)

df2 = pd.read_csv(dataset2, sep=';')

df2.head()

#carregar o dataset
dataset2 = '/content/drive/MyDrive/estatistica_indutiva/dataset2.csv'
df2 = pd.read_csv(dataset2, sep=';')
df2['data'] = pd.to_datetime(df2['data'], format='%d/%m/%Y')

#plotar o gráfico da série temporal
plt.figure(figsize=(10, 6))
plt.plot(df2['data'], df2['valor'], color='blue')
plt.xlabel('Data')
plt.ylabel('Valor')
plt.title('Série Temporal')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

dataset2 = '/content/drive/MyDrive/estatistica_indutiva/dataset2.csv'
df2 = pd.read_csv(dataset2, sep=';', nrows=50)

df2['data'] = pd.to_datetime(df2['data'], format='%d/%m/%Y')

df2.set_index('data', inplace=True)

#linha tendencia
x = np.arange(len(df2))
y = df2['valor']
m, b = np.polyfit(x, y, 1)

#gráfico
plt.figure(figsize=(10, 6))
plt.plot(df2.index, df2['valor'], marker='o', color='blue', linestyle='-', label='Valor')
plt.plot(df2.index, m*x + b, linestyle='--', color='red', label='Linha de Tendência')
plt.xlabel('Data')
plt.ylabel('Valor')
plt.title('Série Temporal do Valor com Linha de Tendência')
plt.xticks(rotation=45)
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

dataset2 = '/content/drive/MyDrive/estatistica_indutiva/dataset2.csv'
df2 = pd.read_csv(dataset2, sep=';')
df2['data'] = pd.to_datetime(df2['data'], format='%d/%m/%Y')
df2.set_index('data', inplace=True)

window = 20
df2['std'] = df2['valor'].rolling(window=window, min_periods=1).std()

df2['mavg'] = df2['valor'].rolling(window=window, min_periods=1).mean()
df2['upper_band'] = df2['mavg'] + 2 * df2['std']
df2['lower_band'] = df2['mavg'] - 2 * df2['std']

plt.figure(figsize=(10, 6))
plt.plot(df2.index, df2['valor'], label='Série Temporal', color='blue')
plt.plot(df2.index, df2['upper_band'], label='Banda Superior', color='red')
plt.plot(df2.index, df2['lower_band'], label='Banda Inferior', color='red')
plt.plot(df2.index, df2['mavg'], '.', label='Banda Central', color='red', markersize=1)
plt.xlabel('Data')
plt.ylabel('Valor')
plt.title('Série Temporal com Bandas de Bollinger')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

df2['data'] = pd.to_datetime(df2['data'], format='%d/%m/%Y')

window = 3
df2['mavg'] = df2['valor'].rolling(window=window, min_periods=1).mean()

plt.figure(figsize=(10, 6))
plt.plot(df2['data'], df2['valor'], color='blue', label='Série Temporal')
plt.plot(df2['data'], df2['mavg'], color='red', label='Média Móvel')
plt.xlabel('Data')
plt.ylabel('Valor')
plt.title('Série Temporal com Média Móvel')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()